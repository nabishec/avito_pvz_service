// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package addpvz

//go:generate minimock -i github.com/nabishec/avito_pvz_service/internal/http_server/handlers/add_pvz.PostPVZ -o post_pvz_mock_test.go -n PostPVZMock -p addpvz

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/nabishec/avito_pvz_service/internal/model"
)

// PostPVZMock implements PostPVZ
type PostPVZMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddPVZ          func(city string) (pp1 *model.PVZResp, err error)
	funcAddPVZOrigin    string
	inspectFuncAddPVZ   func(city string)
	afterAddPVZCounter  uint64
	beforeAddPVZCounter uint64
	AddPVZMock          mPostPVZMockAddPVZ
}

// NewPostPVZMock returns a mock for PostPVZ
func NewPostPVZMock(t minimock.Tester) *PostPVZMock {
	m := &PostPVZMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddPVZMock = mPostPVZMockAddPVZ{mock: m}
	m.AddPVZMock.callArgs = []*PostPVZMockAddPVZParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPostPVZMockAddPVZ struct {
	optional           bool
	mock               *PostPVZMock
	defaultExpectation *PostPVZMockAddPVZExpectation
	expectations       []*PostPVZMockAddPVZExpectation

	callArgs []*PostPVZMockAddPVZParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostPVZMockAddPVZExpectation specifies expectation struct of the PostPVZ.AddPVZ
type PostPVZMockAddPVZExpectation struct {
	mock               *PostPVZMock
	params             *PostPVZMockAddPVZParams
	paramPtrs          *PostPVZMockAddPVZParamPtrs
	expectationOrigins PostPVZMockAddPVZExpectationOrigins
	results            *PostPVZMockAddPVZResults
	returnOrigin       string
	Counter            uint64
}

// PostPVZMockAddPVZParams contains parameters of the PostPVZ.AddPVZ
type PostPVZMockAddPVZParams struct {
	city string
}

// PostPVZMockAddPVZParamPtrs contains pointers to parameters of the PostPVZ.AddPVZ
type PostPVZMockAddPVZParamPtrs struct {
	city *string
}

// PostPVZMockAddPVZResults contains results of the PostPVZ.AddPVZ
type PostPVZMockAddPVZResults struct {
	pp1 *model.PVZResp
	err error
}

// PostPVZMockAddPVZOrigins contains origins of expectations of the PostPVZ.AddPVZ
type PostPVZMockAddPVZExpectationOrigins struct {
	origin     string
	originCity string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPVZ *mPostPVZMockAddPVZ) Optional() *mPostPVZMockAddPVZ {
	mmAddPVZ.optional = true
	return mmAddPVZ
}

// Expect sets up expected params for PostPVZ.AddPVZ
func (mmAddPVZ *mPostPVZMockAddPVZ) Expect(city string) *mPostPVZMockAddPVZ {
	if mmAddPVZ.mock.funcAddPVZ != nil {
		mmAddPVZ.mock.t.Fatalf("PostPVZMock.AddPVZ mock is already set by Set")
	}

	if mmAddPVZ.defaultExpectation == nil {
		mmAddPVZ.defaultExpectation = &PostPVZMockAddPVZExpectation{}
	}

	if mmAddPVZ.defaultExpectation.paramPtrs != nil {
		mmAddPVZ.mock.t.Fatalf("PostPVZMock.AddPVZ mock is already set by ExpectParams functions")
	}

	mmAddPVZ.defaultExpectation.params = &PostPVZMockAddPVZParams{city}
	mmAddPVZ.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddPVZ.expectations {
		if minimock.Equal(e.params, mmAddPVZ.defaultExpectation.params) {
			mmAddPVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPVZ.defaultExpectation.params)
		}
	}

	return mmAddPVZ
}

// ExpectCityParam1 sets up expected param city for PostPVZ.AddPVZ
func (mmAddPVZ *mPostPVZMockAddPVZ) ExpectCityParam1(city string) *mPostPVZMockAddPVZ {
	if mmAddPVZ.mock.funcAddPVZ != nil {
		mmAddPVZ.mock.t.Fatalf("PostPVZMock.AddPVZ mock is already set by Set")
	}

	if mmAddPVZ.defaultExpectation == nil {
		mmAddPVZ.defaultExpectation = &PostPVZMockAddPVZExpectation{}
	}

	if mmAddPVZ.defaultExpectation.params != nil {
		mmAddPVZ.mock.t.Fatalf("PostPVZMock.AddPVZ mock is already set by Expect")
	}

	if mmAddPVZ.defaultExpectation.paramPtrs == nil {
		mmAddPVZ.defaultExpectation.paramPtrs = &PostPVZMockAddPVZParamPtrs{}
	}
	mmAddPVZ.defaultExpectation.paramPtrs.city = &city
	mmAddPVZ.defaultExpectation.expectationOrigins.originCity = minimock.CallerInfo(1)

	return mmAddPVZ
}

// Inspect accepts an inspector function that has same arguments as the PostPVZ.AddPVZ
func (mmAddPVZ *mPostPVZMockAddPVZ) Inspect(f func(city string)) *mPostPVZMockAddPVZ {
	if mmAddPVZ.mock.inspectFuncAddPVZ != nil {
		mmAddPVZ.mock.t.Fatalf("Inspect function is already set for PostPVZMock.AddPVZ")
	}

	mmAddPVZ.mock.inspectFuncAddPVZ = f

	return mmAddPVZ
}

// Return sets up results that will be returned by PostPVZ.AddPVZ
func (mmAddPVZ *mPostPVZMockAddPVZ) Return(pp1 *model.PVZResp, err error) *PostPVZMock {
	if mmAddPVZ.mock.funcAddPVZ != nil {
		mmAddPVZ.mock.t.Fatalf("PostPVZMock.AddPVZ mock is already set by Set")
	}

	if mmAddPVZ.defaultExpectation == nil {
		mmAddPVZ.defaultExpectation = &PostPVZMockAddPVZExpectation{mock: mmAddPVZ.mock}
	}
	mmAddPVZ.defaultExpectation.results = &PostPVZMockAddPVZResults{pp1, err}
	mmAddPVZ.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddPVZ.mock
}

// Set uses given function f to mock the PostPVZ.AddPVZ method
func (mmAddPVZ *mPostPVZMockAddPVZ) Set(f func(city string) (pp1 *model.PVZResp, err error)) *PostPVZMock {
	if mmAddPVZ.defaultExpectation != nil {
		mmAddPVZ.mock.t.Fatalf("Default expectation is already set for the PostPVZ.AddPVZ method")
	}

	if len(mmAddPVZ.expectations) > 0 {
		mmAddPVZ.mock.t.Fatalf("Some expectations are already set for the PostPVZ.AddPVZ method")
	}

	mmAddPVZ.mock.funcAddPVZ = f
	mmAddPVZ.mock.funcAddPVZOrigin = minimock.CallerInfo(1)
	return mmAddPVZ.mock
}

// When sets expectation for the PostPVZ.AddPVZ which will trigger the result defined by the following
// Then helper
func (mmAddPVZ *mPostPVZMockAddPVZ) When(city string) *PostPVZMockAddPVZExpectation {
	if mmAddPVZ.mock.funcAddPVZ != nil {
		mmAddPVZ.mock.t.Fatalf("PostPVZMock.AddPVZ mock is already set by Set")
	}

	expectation := &PostPVZMockAddPVZExpectation{
		mock:               mmAddPVZ.mock,
		params:             &PostPVZMockAddPVZParams{city},
		expectationOrigins: PostPVZMockAddPVZExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddPVZ.expectations = append(mmAddPVZ.expectations, expectation)
	return expectation
}

// Then sets up PostPVZ.AddPVZ return parameters for the expectation previously defined by the When method
func (e *PostPVZMockAddPVZExpectation) Then(pp1 *model.PVZResp, err error) *PostPVZMock {
	e.results = &PostPVZMockAddPVZResults{pp1, err}
	return e.mock
}

// Times sets number of times PostPVZ.AddPVZ should be invoked
func (mmAddPVZ *mPostPVZMockAddPVZ) Times(n uint64) *mPostPVZMockAddPVZ {
	if n == 0 {
		mmAddPVZ.mock.t.Fatalf("Times of PostPVZMock.AddPVZ mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPVZ.expectedInvocations, n)
	mmAddPVZ.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddPVZ
}

func (mmAddPVZ *mPostPVZMockAddPVZ) invocationsDone() bool {
	if len(mmAddPVZ.expectations) == 0 && mmAddPVZ.defaultExpectation == nil && mmAddPVZ.mock.funcAddPVZ == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPVZ.mock.afterAddPVZCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPVZ.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPVZ implements PostPVZ
func (mmAddPVZ *PostPVZMock) AddPVZ(city string) (pp1 *model.PVZResp, err error) {
	mm_atomic.AddUint64(&mmAddPVZ.beforeAddPVZCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPVZ.afterAddPVZCounter, 1)

	mmAddPVZ.t.Helper()

	if mmAddPVZ.inspectFuncAddPVZ != nil {
		mmAddPVZ.inspectFuncAddPVZ(city)
	}

	mm_params := PostPVZMockAddPVZParams{city}

	// Record call args
	mmAddPVZ.AddPVZMock.mutex.Lock()
	mmAddPVZ.AddPVZMock.callArgs = append(mmAddPVZ.AddPVZMock.callArgs, &mm_params)
	mmAddPVZ.AddPVZMock.mutex.Unlock()

	for _, e := range mmAddPVZ.AddPVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmAddPVZ.AddPVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPVZ.AddPVZMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPVZ.AddPVZMock.defaultExpectation.params
		mm_want_ptrs := mmAddPVZ.AddPVZMock.defaultExpectation.paramPtrs

		mm_got := PostPVZMockAddPVZParams{city}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.city != nil && !minimock.Equal(*mm_want_ptrs.city, mm_got.city) {
				mmAddPVZ.t.Errorf("PostPVZMock.AddPVZ got unexpected parameter city, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPVZ.AddPVZMock.defaultExpectation.expectationOrigins.originCity, *mm_want_ptrs.city, mm_got.city, minimock.Diff(*mm_want_ptrs.city, mm_got.city))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPVZ.t.Errorf("PostPVZMock.AddPVZ got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddPVZ.AddPVZMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPVZ.AddPVZMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPVZ.t.Fatal("No results are set for the PostPVZMock.AddPVZ")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmAddPVZ.funcAddPVZ != nil {
		return mmAddPVZ.funcAddPVZ(city)
	}
	mmAddPVZ.t.Fatalf("Unexpected call to PostPVZMock.AddPVZ. %v", city)
	return
}

// AddPVZAfterCounter returns a count of finished PostPVZMock.AddPVZ invocations
func (mmAddPVZ *PostPVZMock) AddPVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPVZ.afterAddPVZCounter)
}

// AddPVZBeforeCounter returns a count of PostPVZMock.AddPVZ invocations
func (mmAddPVZ *PostPVZMock) AddPVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPVZ.beforeAddPVZCounter)
}

// Calls returns a list of arguments used in each call to PostPVZMock.AddPVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPVZ *mPostPVZMockAddPVZ) Calls() []*PostPVZMockAddPVZParams {
	mmAddPVZ.mutex.RLock()

	argCopy := make([]*PostPVZMockAddPVZParams, len(mmAddPVZ.callArgs))
	copy(argCopy, mmAddPVZ.callArgs)

	mmAddPVZ.mutex.RUnlock()

	return argCopy
}

// MinimockAddPVZDone returns true if the count of the AddPVZ invocations corresponds
// the number of defined expectations
func (m *PostPVZMock) MinimockAddPVZDone() bool {
	if m.AddPVZMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPVZMock.invocationsDone()
}

// MinimockAddPVZInspect logs each unmet expectation
func (m *PostPVZMock) MinimockAddPVZInspect() {
	for _, e := range m.AddPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostPVZMock.AddPVZ at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddPVZCounter := mm_atomic.LoadUint64(&m.afterAddPVZCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPVZMock.defaultExpectation != nil && afterAddPVZCounter < 1 {
		if m.AddPVZMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostPVZMock.AddPVZ at\n%s", m.AddPVZMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostPVZMock.AddPVZ at\n%s with params: %#v", m.AddPVZMock.defaultExpectation.expectationOrigins.origin, *m.AddPVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPVZ != nil && afterAddPVZCounter < 1 {
		m.t.Errorf("Expected call to PostPVZMock.AddPVZ at\n%s", m.funcAddPVZOrigin)
	}

	if !m.AddPVZMock.invocationsDone() && afterAddPVZCounter > 0 {
		m.t.Errorf("Expected %d calls to PostPVZMock.AddPVZ at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddPVZMock.expectedInvocations), m.AddPVZMock.expectedInvocationsOrigin, afterAddPVZCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PostPVZMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddPVZInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PostPVZMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PostPVZMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddPVZDone()
}
